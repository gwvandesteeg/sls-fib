'use strict';

// tests for fibonacci
// Generated by serverless-mocha-plugin

const mochaPlugin = require('serverless-mocha-plugin');
mochaPlugin.chai.use(require('chai-json-schema'));
const expect = mochaPlugin.chai.expect;
let wrapped = mochaPlugin.getWrapper('fibonacci', '/fibonacci.js', 'handler');
const jsonschema = require('jsonschema');

var validator = new jsonschema.Validator();
var valid_schema = require('../schema/FibonacciSuccessResponse.json');
var invalid_schema = require('../schema/FibonacciErrorResponse.json');

describe('fibonacci lambda tests', function () {
  // set a 5 second timeout on the entire suite
  this.timeout(5000);

  before((done) => {
    done();
  });

  // pull the minimums and maximums from the schema definition
  var valid_inputs = [
    0, 1, 2, 3, 4, 5,
    valid_schema.properties.input.maximum,
    -1, -2, -3,
    valid_schema.properties.input.minimum
  ];
  var expected_results = [
    0, 1, 1, 2, 3, 5,
    valid_schema.properties.result.maximum,
    -1, -1, -2,
    valid_schema.properties.result.minimum
  ];

  var items = valid_inputs.map(function (input, index) {
    return [input, expected_results[index]];
  });
  items.forEach(function (pair, index) {
    var number = pair[0];
    var exp_result = pair[1];

    it('test valid input ' + number, function () {
      return wrapped.run({
        "number": number
      }).then((response) => {
        const msg = `number=${number}; expected_result=${exp_result}`;
        expect(response, msg).to.not.be.empty;
        expect(response.statusCode, msg).to.be.equal(200);
        expect(response, msg).to.have.property('body');
        const body = JSON.parse(response.body);
        // validate response with a JSON Schema
        expect(body).to.be.jsonSchema(valid_schema);
        expect(validator.validate(body, invalid_schema).valid, msg).to.be.false;
        // validate actual response content
        expect(body.input, msg).to.equal(number);
        expect(body.result, msg).to.equal(exp_result);
      });
    }).timeout(100);

  });

  it('test invalid inputs are handled correctly - string', function () {
    return wrapped.run({
      "number": "steve"
    }).then((response) => {
      expect(response).to.not.be.empty;
      expect(response.statusCode).to.be.equal(400);
      expect(response).to.have.property('body');
      const body = JSON.parse(response.body);
      // validate response with a JSON Schema
      expect(validator.validate(body, valid_schema).valid).to.be.false;
      expect(validator.validate(body, invalid_schema).valid).to.be.true;
    });
  });

  it('test invalid inputs are handled correctly - non-integer float', function () {
    return wrapped.run({
      "number": 1.1
    }).then((response) => {
      expect(response).to.not.be.empty;
      expect(response.statusCode).to.be.equal(400);
      expect(response).to.have.property('body');
      const body = JSON.parse(response.body);
      // validate response with a JSON Schema
      expect(validator.validate(body, valid_schema).valid).to.be.false;
      expect(validator.validate(body, invalid_schema).valid).to.be.true;
    });
  });

  it('test invalid inputs are handled correctly - object', function () {
    return wrapped.run({
      "number": {}
    }).then((response) => {
      expect(response).to.not.be.empty;
      expect(response.statusCode).to.be.equal(400);
      expect(response).to.have.property('body');
      const body = JSON.parse(response.body);
      // validate response with a JSON Schema
      expect(validator.validate(body, valid_schema).valid).to.be.false;
      expect(validator.validate(body, invalid_schema).valid).to.be.true;
    });
  });

  it('test invalid inputs are handled correctly - list', function () {
    return wrapped.run({
      "number": []
    }).then((response) => {
      expect(response).to.not.be.empty;
      expect(response.statusCode).to.be.equal(400);
      expect(response).to.have.property('body');
      const body = JSON.parse(response.body);
      // validate response with a JSON Schema
      expect(validator.validate(body, valid_schema).valid).to.be.false;
      expect(validator.validate(body, invalid_schema).valid).to.be.true;
    });
  });

  it('test invalid inputs are handled correctly - number too large', function () {
    return wrapped.run({
      "number": valid_schema.properties.input.maximum + 1,
    }).then((response) => {
      expect(response).to.not.be.empty;
      expect(response.statusCode).to.be.equal(400);
      expect(response).to.have.property('body');
      const body = JSON.parse(response.body);
      // validate response with a JSON Schema
      expect(validator.validate(body, valid_schema).valid).to.be.false;
      expect(validator.validate(body, invalid_schema).valid).to.be.true;
    });
  });

});